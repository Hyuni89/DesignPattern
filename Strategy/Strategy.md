# Strategy Pattern  
알고리즘 군을 정의하고 각각을 **캡슐화**하여 **교환**해서 사용할 수 있다.  
단순 상속을 이용한 구현보다 동작에 대한 유연성이 극대화 된다.  

> 예를 들어, 동물이라는 추상클래스에서 하늘을 나는 동작(fly)의 기능을 추가한 '새'라는 객체를 구현한다고 가정해 보자.  
> 추상클래스에서 fly라는 기능을 추가하는 경우 하늘을 날지 않는 육지 동물 객체를 생성할 때, fly 동작이 따라오는 문제가 발생한다. fly 기능을 인터페이스로 분리해 하늘을 나는 동물을 구현 할 때만 상속받게 될 경우, 모든 새들에 대한 동작을 구현해 주어야 하고 중복 코드가 많이 발생하는 문제가 발생한다. 수정이라도 생기는 경우 모든 새의 동작을 찾아 일일이 수정해 주어야 한다. 그렇기 때문에 fly라는 기능을 분리하고 캡슐화 해야 할 필요가 있다는 사실을 알 수 있다.  

## 디자인 원칙  
- 달라지는 부분을 찾아내고, 달라지지 않는 부분으로 부터 분리  
- 상속보다는 구성을 활용  
- 구현이 아닌 인터페이스에 초점  

## Idea  
LM을 load 할때, 언어별 동작은 read, load, write으로 구분 할 수 있지만 세부적인 동작은 언어별 특성마다 다를 수 있다. 예를 들면, 영어의 경우 read 한 데이터를 바로 메모리에 올려서 처리 할 수 있지만 한글의 경우 메모리에 올릴때 조합형으로 변형해야 처리가 편하다. 출력 역시 영어는 메모리에 적재된 그대로 출력하면 되지만 한글은 분리된 조합형을 완성형으로 바꿔서 출력해야 한다. 큰 흐름은 동일하지만 세부 동작이 다르므로 다른 부분을 묶어 하나의 인터페이스를 만들고, 세부 구현을 통해 모듈을 갈아 끼면 같은 클래스에서 다른 동작을 할 수 있게 된다.  

- 달라지는 부분 (read, write)
